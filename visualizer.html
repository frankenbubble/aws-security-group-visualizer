<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AWS Network Visualizer</title>
  <script src="https://unpkg.com/vis-network@9.1.9/dist/vis-network.min.js"></script>
  <link href="https://unpkg.com/vis-network@9.1.9/dist/vis-network.min.css" rel="stylesheet" type="text/css" />
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f0f2f5;
      color: #333;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden; 
    }
    #controls, #secondaryFiltersContainer {
      padding: 10px 15px;
      background: #ffffff;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      border-bottom: 1px solid #d1d5db;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
      flex-shrink: 0; 
    }
    #secondaryFiltersContainer {
        border-top: 1px dashed #e0e0e0;
    }
    #controls label, #controls button, #controls select, #controls span,
    #secondaryFiltersContainer label, #secondaryFiltersContainer input, #secondaryFiltersContainer select, #secondaryFiltersContainer button {
      font-size: 13px;
    }
    #controls input[type="file"] {
      border: 1px solid #ccc;
      padding: 5px;
      border-radius: 4px;
    }

    /* Button Styling */
    #controls button, 
    #secondaryFiltersContainer button {
      padding: 7px 10px;
      border-radius: 5px;
      border: 1px solid #007bff;
      background-color: #007bff;
      color: white;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    #controls button:hover, 
    #secondaryFiltersContainer button:hover {
      background-color: #0056b3;
    }
    #controls button:disabled, 
    #secondaryFiltersContainer button:disabled {
      background-color: #cccccc;
      border-color: #cccccc;
      cursor: not-allowed;
    }

    /* Select (Dropdown and Multiselect) Styling */
    #controls select, 
    #secondaryFiltersContainer select {
      padding: 7px 10px;
      border-radius: 5px;
      border: 1px solid #ccc; 
      background-color: #fff; 
      color: #333; 
      cursor: pointer;
    }
    #controls select:disabled { 
      background-color: #e9ecef;
      color: #6c757d;
      border-color: #ced4da;
      cursor: not-allowed;
    }
    #secondaryFiltersContainer select[multiple] { 
        height: 70px; 
        min-width: 180px;
    }
     #secondaryFiltersContainer input[type="text"] { 
        padding: 7px 10px;
        border-radius: 5px;
        border: 1px solid #ccc;
        font-size: 13px;
    }
    #secondaryFiltersContainer label input[type="checkbox"] {
        margin-right: 4px;
        vertical-align: middle;
    }

    #status {
      margin-left: auto; 
      font-style: italic;
      color: #555;
    }
    
    #mainContentContainer {
        display: flex;
        flex-grow: 1;
        overflow: hidden; 
    }

    #network {
      flex-grow: 1; 
      border-top: 1px solid #ccc; 
      background-color: #fdfdfd;
      overflow: hidden; 
      position: relative; 
      border-right: 1px solid #d1d5db; 
    }
    #unusedSgListContainer {
        width: 250px; 
        flex-shrink: 0;
        padding: 10px;
        background-color: #f8f9fa;
        overflow-y: auto;
        border-top: 1px solid #ccc; 
    }
    #unusedSgListContainer h4 {
        margin-top: 0;
        margin-bottom: 10px;
        font-size: 14px;
        color: #333;
        border-bottom: 1px solid #eee;
        padding-bottom: 5px;
    }
    #unusedSgListContainer ul {
        list-style-type: none;
        padding-left: 0;
        margin: 0;
    }
    #unusedSgListContainer li {
        font-size: 12px;
        padding: 4px 0;
        border-bottom: 1px solid #f0f0f0;
        color: #555;
    }
    #unusedSgListContainer li:last-child {
        border-bottom: none;
    }


    .vis-tooltip {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        padding: 8px;
        background-color: #333;
        color: white;
        border: none;
        border-radius: 4px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        font-size: 13px;
        white-space: pre-wrap; 
    }
    .modal {
      display: none; position: fixed; z-index: 1000; left: 0; top: 0;
      width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); 
    }
    .modal-content {
      background-color: #fefefe; margin: 10% auto; padding: 20px; border: 1px solid #888;
      width: 80%; max-width: 600px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); position: relative;
    }
    .modal-close-btn {
      color: #aaa; float: right; font-size: 28px; font-weight: bold; line-height: 1;
    }
    .modal-close-btn:hover, .modal-close-btn:focus {
      color: black; text-decoration: none; cursor: pointer;
    }
    .modal-title { margin-top: 0; margin-bottom: 15px; font-size: 18px; color: #333; }
    .modal-body {
      font-size: 14px; line-height: 1.6; max-height: 60vh; overflow-y: auto;
      white-space: pre-wrap; word-wrap: break-word; background-color: #f9f9f9;
      padding: 10px; border-radius: 4px; border: 1px solid #eee;
    }
    .help-icon {
        cursor: pointer;
        color: #007bff;
        font-weight: bold;
        margin-left: 3px;
        display: inline-block;
        border: 1px solid #007bff;
        border-radius: 50%;
        width: 16px;
        height: 16px;
        line-height: 16px;
        text-align: center;
        font-size: 12px;
    }
    .cli-command {
        background-color: #e9ecef;
        padding: 8px;
        border-radius: 4px;
        font-family: 'Courier New', Courier, monospace;
        margin-bottom: 10px;
        display: block;
        word-break: break-all;
    }
  </style>
</head>
<body>

<div id="controls">
  <label>Instances JSON: <input type="file" id="instancesFile" accept=".json"> <span class="help-icon" id="instancesHelpIcon">?</span></label>
  <label>SGs JSON: <input type="file" id="sgsFile" accept=".json"> <span class="help-icon" id="sgsHelpIcon">?</span></label>
  <button id="generateBtn" disabled>Generate Diagram</button>
  <label for="stateFilter">State:</label>
  <select id="stateFilter" disabled>
    <option value="all">All States</option>
    <option value="running">Running</option>
    <option value="stopped">Stopped</option>
    <option value="pending">Pending</option>
    <option value="terminated">Terminated</option>
    <option value="shutting-down">Shutting-down</option>
  </select>
  <label for="instanceFilter">Focus Instance:</label>
  <select id="instanceFilter" disabled><option value="">-- Select Instance --</option></select>
  <span id="status">Drop AWS CLI JSON outputs</span>
</div>

<div id="secondaryFiltersContainer" style="display: none;">
  <label>Protocol: <input type="text" id="protocolFilterInput" placeholder="e.g., tcp, all"></label>
  <label>Port: <input type="text" id="portFilterInput" placeholder="e.g., 80, 443"></label>
  <label>Filter by Specific Connected Node(s): <select id="connectedNodeFilterSelect" multiple size="3"><option value="" disabled>-- Select Nodes --</option></select></label>
  <button id="applySecondaryFiltersBtn">Apply Sub-Filters</button>
  <button id="resetSecondaryFiltersBtn">Reset Sub-Filters</button>
  <label style="margin-left: 15px;"><input type="checkbox" id="circularFilteredViewCheckbox"> Circular Layout for Filtered</label>
</div>

<div id="mainContentContainer">
    <div id="network"></div>
    <div id="unusedSgListContainer">
        <h4>Unused Security Groups</h4>
        <ul id="unusedSgList">
            <!-- Unused SGs will be listed here -->
        </ul>
    </div>
</div>


<!-- Node Detail Modal -->
<div id="nodeDetailModal" class="modal">
  <div class="modal-content">
    <span id="modalCloseBtn" class="modal-close-btn">&times;</span>
    <h3 id="modalTitle">Node Details</h3>
    <pre id="modalBody" class="modal-body"></pre>
  </div>
</div>

<!-- Help Modal -->
<div id="helpModal" class="modal">
  <div class="modal-content">
    <span id="helpModalCloseBtn" class="modal-close-btn">&times;</span>
    <h3 id="helpModalTitle">Generating JSON Files</h3>
    <div id="helpModalBody" class="modal-body" style="white-space:normal;">
        <p>To generate the required JSON files, use the AWS CLI:</p>
        <p><strong>For Instances JSON:</strong></p>
        <code class="cli-command">aws ec2 describe-instances > describe-instances.json</code>
        <p><strong>For Security Groups JSON:</strong></p>
        <code class="cli-command">aws ec2 describe-security-groups > describe-security-groups.json</code>
        <p>Ensure your AWS CLI is configured with the necessary permissions and region.</p>
    </div>
  </div>
</div>


<script>
  let instancesJson = null, sgsJson = null;
  let network;
  let globalNodes = new vis.DataSet();
  let globalEdges = new vis.DataSet();
  
  let baseFilteredNodes = new vis.DataSet(); 
  let baseFilteredEdges = new vis.DataSet(); 
  let currentFocusedInstanceId = null;

  let instanceMap = {}; 
  let sgToInstances = {}; 
  let allSgIdsFromInstances = new Set(); 
  let isGraphReady = false;

  const instanceFileInput = document.getElementById('instancesFile');
  const sgFileInput = document.getElementById('sgsFile');
  const generateBtn = document.getElementById('generateBtn');
  const stateFilterSelect = document.getElementById('stateFilter');
  const instanceFilterSelect = document.getElementById('instanceFilter');
  const status = document.getElementById('status');
  const unusedSgListUl = document.getElementById('unusedSgList');
  const unusedSgListContainer = document.getElementById('unusedSgListContainer');


  const secondaryFiltersContainer = document.getElementById('secondaryFiltersContainer');
  const protocolFilterInput = document.getElementById('protocolFilterInput');
  const portFilterInput = document.getElementById('portFilterInput');
  const connectedNodeFilterSelect = document.getElementById('connectedNodeFilterSelect');
  const applySecondaryFiltersBtn = document.getElementById('applySecondaryFiltersBtn');
  const resetSecondaryFiltersBtn = document.getElementById('resetSecondaryFiltersBtn');
  const circularFilteredViewCheckbox = document.getElementById('circularFilteredViewCheckbox');


  const nodeDetailModal = document.getElementById('nodeDetailModal');
  const modalCloseBtn = document.getElementById('modalCloseBtn');
  const modalTitle = document.getElementById('modalTitle');
  const modalBody = document.getElementById('modalBody');

  const helpModal = document.getElementById('helpModal');
  const helpModalCloseBtn = document.getElementById('helpModalCloseBtn');
  const instancesHelpIcon = document.getElementById('instancesHelpIcon');
  const sgsHelpIcon = document.getElementById('sgsHelpIcon');


  function loadJsonFromFile(inputElement, callback) {
    const file = inputElement.files[0];
    if (!file) { status.textContent = "No file selected."; return; }
    if (file.type !== "application/json") {
        status.textContent = `Error: ${file.name} is not a JSON file.`; inputElement.value = ""; return;
    }
    const reader = new FileReader();
    reader.onload = e => {
      try { callback(JSON.parse(e.target.result)); } 
      catch (error) {
        status.textContent = `Error parsing JSON from ${file.name}: ${error.message}`; inputElement.value = ""; 
        if (inputElement.id === 'instancesFile') instancesJson = null; if (inputElement.id === 'sgsFile') sgsJson = null;
        checkFilesReady();
      }
    };
    reader.onerror = () => { status.textContent = `Error reading file ${file.name}.`; inputElement.value = ""; };
    reader.readAsText(file);
  }

  function checkFilesReady() {
    if (instancesJson && sgsJson) {
      processInitialData(); 
      generateBtn.disabled = false;
      stateFilterSelect.disabled = false;
      status.textContent = "Ready to generate diagram.";
    } else {
      generateBtn.disabled = true; stateFilterSelect.disabled = true; instanceFilterSelect.disabled = true;
      if (!instancesJson && !sgsJson) status.textContent = "Drop AWS CLI JSON outputs";
      else if (!instancesJson) status.textContent = "Waiting for Instances JSON...";
      else status.textContent = "Waiting for Security Groups JSON...";
    }
  }
  
  function processInitialData() {
    instanceMap = {}; sgToInstances = {}; allSgIdsFromInstances.clear();
    const sgIdToNameMap = new Map();
    if (sgsJson && sgsJson.SecurityGroups) {
        for (const sgData of sgsJson.SecurityGroups) {
            sgIdToNameMap.set(sgData.GroupId, `SG: ${sgData.GroupName || sgData.GroupId}`);
        }
    }

    if (instancesJson && instancesJson.Reservations) {
      for (const res of instancesJson.Reservations) {
        for (const inst of res.Instances) {
          const id = inst.InstanceId;
          const nameTag = inst.Tags?.find(t => t.Key === "Name")?.Value;
          const displayName = nameTag ? `${nameTag} (${id.substring(0,8)}...)` : id;
          let memberOfSGsList = [];
          if (inst.SecurityGroups) {
            for (const sgRef of inst.SecurityGroups) {
              sgToInstances[sgRef.GroupId] = sgToInstances[sgRef.GroupId] || [];
              sgToInstances[sgRef.GroupId].push(id);
              allSgIdsFromInstances.add(sgRef.GroupId); 
              memberOfSGsList.push({id: sgRef.GroupId, name: sgIdToNameMap.get(sgRef.GroupId) || `SG: ${sgRef.GroupId}` });
            }
          }
          instanceMap[id] = { name: displayName, originalName: nameTag || id, data: inst, memberOfSGs: memberOfSGsList };
        }
      }
    }
  }
  
  function getNodeColorByState(instanceData) {
    if (!instanceData || !instanceData.State) return { background: "#CFD8DC", border: "#90A4AE" }; 
    const state = instanceData.State.Name?.toLowerCase();
    if (state === "running") return { background: "#4CAF50", border: "#388E3C" }; 
    if (state === "stopped") return { background: "#B0BEC5", border: "#78909C" }; 
    if (state === "terminated" || state === "shutting-down") return { background: "#F44336", border: "#D32F2F" }; 
    if (state === "pending") return { background: "#2196F3", border: "#1976D2" }; 
    return { background: "#CFD8DC", border: "#90A4AE" }; 
  }

  function generateDiagram() {
    if (!instancesJson || !sgsJson) { status.textContent = "Error: Missing JSON data."; return; }
    globalNodes.clear(); globalEdges.clear();
    unusedSgListUl.innerHTML = ''; 
    status.textContent = "Generating diagram...";
    isGraphReady = false; 
    secondaryFiltersContainer.style.display = 'none';
    unusedSgListContainer.style.display = 'block'; 
    instanceFilterSelect.value = ""; 
    currentFocusedInstanceId = null;
    circularFilteredViewCheckbox.checked = false;

    const selectedState = stateFilterSelect.value;
    const tempNodeProperties = []; 
    const visibleInstanceIds = new Set(); 

    if (instancesJson && instancesJson.Reservations) {
      for (const res of instancesJson.Reservations) {
        for (const inst of res.Instances) { 
          if (selectedState === "all" || inst.State.Name.toLowerCase() === selectedState) {
            const id = inst.InstanceId;
            visibleInstanceIds.add(id); 
            const displayName = instanceMap[id]?.name || id; 
            const nodeColor = getNodeColorByState(inst); 
            tempNodeProperties.push({ 
              id, label: displayName, 
              title: `Instance: ${instanceMap[id]?.originalName || id}\nID: ${id}\nType: ${inst.InstanceType}\nState: ${inst.State?.Name}`,
              shape: "box", color: nodeColor, font: { size: 11, multi: false }, nodeType: 'instance'
            });
          }
        }
      }
    }

    const sgIdToNameMap = new Map(); 
    if (sgsJson && sgsJson.SecurityGroups) {
        for (const sgData of sgsJson.SecurityGroups) {
            sgIdToNameMap.set(sgData.GroupId, `SG: ${sgData.GroupName || sgData.GroupId}`);
        }
    }
    
    const externalTargetSgDetails = new Map();
    if (sgsJson && sgsJson.SecurityGroups) {
      for (const sgRuleSource of sgsJson.SecurityGroups) {
        const instancesUsingThisRuleSourceSg = (sgToInstances[sgRuleSource.GroupId] || []).filter(id => visibleInstanceIds.has(id));
        if (instancesUsingThisRuleSourceSg.length === 0) continue; 

        if (sgRuleSource.IpPermissions) {
          for (const rule of sgRuleSource.IpPermissions) {
            if (rule.UserIdGroupPairs) {
              for (const targetSgPair of rule.UserIdGroupPairs) {
                const targetSgId = targetSgPair.GroupId;
                if (!allSgIdsFromInstances.has(targetSgId)) { 
                  if (instancesUsingThisRuleSourceSg.length > 0) {
                    if (!externalTargetSgDetails.has(targetSgId)) {
                      externalTargetSgDetails.set(targetSgId, {
                        id: targetSgId,
                        name: sgIdToNameMap.get(targetSgId) || `SG: ${targetSgId}`,
                        description: sgsJson.SecurityGroups.find(sg => sg.GroupId === targetSgId)?.Description || 'N/A'
                      });
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    externalTargetSgDetails.forEach(sgDetail => {
        const sgLabelSimple = sgDetail.name; 
        tempNodeProperties.push({
            id: sgDetail.id,
            label: sgLabelSimple, 
            title: `External Target SG: ${sgDetail.name}\nID: ${sgDetail.id}\nDescription: ${sgDetail.description}`, 
            shape: 'ellipse', 
            color: { background: '#FFDAB9', border: '#FFA07A' }, 
            font: { size: 10, multi: false }, 
            nodeType: 'external-sg'
        });
    });


    if (sgsJson && sgsJson.SecurityGroups) {
        for (const sgData of sgsJson.SecurityGroups) {
            const sgDisplayName = sgIdToNameMap.get(sgData.GroupId) || `SG: ${sgData.GroupId}`;
            if (!allSgIdsFromInstances.has(sgData.GroupId) && !externalTargetSgDetails.has(sgData.GroupId)) { 
                 const li = document.createElement('li');
                 li.textContent = `${sgDisplayName} (${sgData.GroupId})`;
                 li.title = `ID: ${sgData.GroupId}\nDescription: ${sgData.Description || 'N/A'}`;
                 unusedSgListUl.appendChild(li);
            }
        }
    }


    if (tempNodeProperties.length === 0) { 
        status.textContent = "No items to display based on current filters."; 
        instanceFilterSelect.disabled = true; 
        if (network) network.setData({nodes: new vis.DataSet(), edges: new vis.DataSet()});
        return; 
    }

    const radius = Math.max(200, tempNodeProperties.length * 30);
    const angleStep = tempNodeProperties.length > 0 ? (2 * Math.PI) / tempNodeProperties.length : 0;
    tempNodeProperties.forEach((props, i) => globalNodes.add({...props, x: radius*Math.cos(i*angleStep), y: radius*Math.sin(i*angleStep), fixed: {x:true, y:true}}));

    instanceFilterSelect.innerHTML = '<option value="">-- Select Instance --</option>';
    const sortedVisibleInstances = Object.entries(instanceMap)
        .filter(([id]) => visibleInstanceIds.has(id)) 
        .sort(([,a],[,b]) => a.originalName.localeCompare(b.originalName));
    
    for (const [id, data] of sortedVisibleInstances) {
      const opt = document.createElement("option");
      opt.value = id; opt.textContent = data.name;
      instanceFilterSelect.appendChild(opt);
    }
    instanceFilterSelect.disabled = sortedVisibleInstances.length === 0;


    // *** CORRECTED EDGE CREATION LOGIC ***
    if (sgsJson && sgsJson.SecurityGroups) {
      for (const destSg of sgsJson.SecurityGroups) { // The SG defining the ingress rule IS THE DESTINATION
        const destinationNodeIds = (sgToInstances[destSg.GroupId] || []).filter(id => visibleInstanceIds.has(id));
        if (destinationNodeIds.length === 0) continue; // Skip if this SG isn't on any visible instances
        
        if (destSg.IpPermissions) {
          for (const rule of destSg.IpPermissions) {
            const proto = rule.IpProtocol === "-1" ? "all" : rule.IpProtocol;
            const port = (rule.FromPort != null && rule.ToPort != null) ? (rule.FromPort === rule.ToPort ? `${rule.FromPort}` : `${rule.FromPort}-${rule.ToPort}`) : "any";
            const destSgName = sgIdToNameMap.get(destSg.GroupId) || `SG: ${destSg.GroupId}`;
            
            if (rule.UserIdGroupPairs) {
              for (const sourceSgPair of rule.UserIdGroupPairs) { // The SG in the rule pair IS THE SOURCE
                const sourceSgId = sourceSgPair.GroupId;
                const sourceSgName = sgIdToNameMap.get(sourceSgId) || `SG: ${sourceSgId}`;
                let sourceNodeIds = [];

                if (allSgIdsFromInstances.has(sourceSgId)) { // Source is an instance
                    sourceNodeIds = (sgToInstances[sourceSgId] || []).filter(id => visibleInstanceIds.has(id));
                } else if (externalTargetSgDetails.has(sourceSgId)) { // Source is an external SG node
                    sourceNodeIds = [sourceSgId];
                }

                const edgeLabel = `${proto}: ${port}\n(via ${destSgName.substring(0,28)}${destSgName.length > 28 ? '...' : ''})`;

                for (const fromId of sourceNodeIds) {
                  for (const toId of destinationNodeIds) {
                    if (fromId !== toId && globalNodes.get(fromId) && globalNodes.get(toId)) { 
                      globalEdges.add({
                        from: fromId, to: toId, label: edgeLabel, 
                        protocolPortData: `${proto}:${port}`, 
                        sgNameData: destSgName, // The SG on the destination that allows the traffic
                        title: `Rule in ${destSgName}\nAllows: ${proto}:${port}\nFrom SG: ${sourceSgName}\nTo SG: ${destSgName}`,
                        arrows: "to", font: { align: "middle", size: 9 }, 
                        color: { color: "#6495ED", highlight: "#4169E1", hover: "#4169E1" }, 
                        smooth: { type: "cubicBezier", forceDirection: "horizontal", roundness: 0.3 }
                      });
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    const container = document.getElementById("network");
    const data = { nodes: globalNodes, edges: globalEdges };
    const options = {
      physics: false, interaction: { hover: true, dragNodes: false, dragView: true, zoomView: true, tooltipDelay: 200 },
      nodes: { borderWidth: 1, borderWidthSelected: 2, font: { color: '#333333' } },
      edges: { width: 1, hoverWidth: 0.5, selectionWidth: 1.5, smooth: { enabled: true, type: "cubicBezier", forceDirection: 'horizontal', roundness: 0.2 } },
    };
    if (network) { network.destroy(); }
    network = new vis.Network(container, data, options);
    
    network.on("click", function (params) {
        if (params.nodes.length > 0) {
            const nodeId = params.nodes[0];
            const nodeDataFromNetwork = network.body.data.nodes.get(nodeId); 
            const instanceDetailsFromMap = instanceMap[nodeId]; 
            let modalText = "";

            const baseTitle = nodeDataFromNetwork?.title || 
                             (instanceDetailsFromMap ? `Instance: ${instanceDetailsFromMap.originalName || nodeId}\nID: ${nodeId}` : `Node: ${nodeId}`);
            modalTitle.textContent = `Details for ${instanceDetailsFromMap?.originalName || nodeDataFromNetwork?.label.split('\n')[0] || nodeId}`;
            modalBody.textContent = baseTitle; 

            const isInFilteredView = !!currentFocusedInstanceId && baseFilteredNodes.get(nodeId);
            
            if (isInFilteredView && nodeDataFromNetwork?.label.includes('\n')) { 
                 modalBody.textContent += "\n\nConnections (to/from focused):\n" + nodeDataFromNetwork.label.substring(nodeDataFromNetwork.label.indexOf('\n') + 1);
            }

            if (instanceDetailsFromMap) { 
                const rawInstData = instanceDetailsFromMap.data;
                 if (rawInstData && !baseTitle.includes("Instance Type:")) { 
                    modalBody.textContent += `\n\nInstance Type: ${rawInstData.InstanceType || 'N/A'}`;
                    modalBody.textContent += `\nState: ${rawInstData.State?.Name || 'N/A'}`;
                    if(rawInstData.PrivateIpAddress) modalBody.textContent += `\nPrivate IP: ${rawInstData.PrivateIpAddress}`;
                    if(rawInstData.PublicIpAddress) modalBody.textContent += `\nPublic IP: ${rawInstData.PublicIpAddress}`;
                }
                if (instanceDetailsFromMap.memberOfSGs && instanceDetailsFromMap.memberOfSGs.length > 0) {
                    modalBody.textContent += "\n\nMember of Security Groups:";
                    instanceDetailsFromMap.memberOfSGs.forEach(sg => {
                        modalBody.textContent += `\n- ${sg.name}`; 
                    });
                }
            }
            nodeDetailModal.style.display = "block";
        }
    });

    network.fit({ animation: { duration: 800, easingFunction: "easeInOutQuad" } });
    isGraphReady = true; 
    status.textContent = `Diagram ready (${globalNodes.length} nodes, ${globalEdges.length} connections).`;
  }
  
  function arrangeNodesInCircle(nodesDataSet, containerWidth, containerHeight) {
    const nodeArray = nodesDataSet.get();
    if (nodeArray.length === 0) return;
    const radiusFactor = nodeArray.length > 1 ? 2.5 : 1; 
    const radius = Math.min(containerWidth / radiusFactor, containerHeight / radiusFactor, nodeArray.length * 40 + 30);
    const angleStep = nodeArray.length > 1 ? (2 * Math.PI) / nodeArray.length : 0;
    const updates = [];
    nodeArray.forEach((node, index) => {
        updates.push({
            id: node.id,
            x: nodeArray.length === 1 ? 0 : radius * Math.cos(index * angleStep), 
            y: nodeArray.length === 1 ? 0 : radius * Math.sin(index * angleStep),
            fixed: { x: true, y: true }
        });
    });
    nodesDataSet.update(updates);
}


  instanceFilterSelect.addEventListener("change", function () {
    if (!isGraphReady || !network) { status.textContent = "Generate diagram first."; this.value = ""; return; }
    currentFocusedInstanceId = this.value; 
    unusedSgListContainer.style.display = currentFocusedInstanceId ? 'none' : 'block';


    if (!currentFocusedInstanceId) { 
      status.textContent = "Displaying full diagram based on state filter...";
      generateDiagram(); 
      secondaryFiltersContainer.style.display = 'none'; resetSecondaryFilterInputs(); return;
    }

    const selectedInstanceName = instanceMap[currentFocusedInstanceId]?.name || currentFocusedInstanceId;
    status.textContent = `Filtering for ${selectedInstanceName}...`;
    
    baseFilteredNodes.clear(); baseFilteredEdges.clear(); 
    const focusedNodeOriginal = globalNodes.get(currentFocusedInstanceId);

    if (!focusedNodeOriginal) { status.textContent = `Error: Instance ${selectedInstanceName} not found.`; this.value = ""; return; }
    baseFilteredNodes.add({...focusedNodeOriginal}); 

    const connectedNodesForDropdown = new Map(); 

    globalEdges.forEach(edge => { 
      let currentEdgeToAdd = null; let connectedNodeId = null;
      const sgDisplayName = edge.label.split('\n')[1]?.replace('(via ','').replace(')','') || edge.sgNameData || "Unknown SG"; 

      if (edge.from === currentFocusedInstanceId && edge.to !== currentFocusedInstanceId) { 
        connectedNodeId = edge.to;
        currentEdgeToAdd = { ...edge, id: edge.id + "_fp", label: sgDisplayName, color: { color: 'green', highlight: '#388E3C' }};
      } else if (edge.to === currentFocusedInstanceId && edge.from !== currentFocusedInstanceId) { 
        connectedNodeId = edge.from;
        currentEdgeToAdd = { ...edge, id: edge.id + "_fp", label: sgDisplayName, color: { color: 'red', highlight: '#D32F2F' }};
      } else if (edge.from === currentFocusedInstanceId && edge.to === currentFocusedInstanceId) { 
         currentEdgeToAdd = { ...edge, id: edge.id + "_fp", label: sgDisplayName, color: { color: 'purple', highlight: '#7B1FA2' }, smooth: { type: 'cubicBezier', roundness: 0.7 } };
      }

      if (currentEdgeToAdd) {
        baseFilteredEdges.add(currentEdgeToAdd);
        if (connectedNodeId) {
          const originalNode = globalNodes.get(connectedNodeId); 
          if (originalNode && !baseFilteredNodes.get(connectedNodeId)) { 
             baseFilteredNodes.add({...originalNode }); 
             if (!connectedNodesForDropdown.has(connectedNodeId)) {
                const connectedNodeLabel = originalNode.label.split('\n')[0]; 
                connectedNodesForDropdown.set(connectedNodeId, connectedNodeLabel);
             }
          }
        }
      }
    });
    
    const { nodesWithUpdatedInfo, edgesWithUpdatedInfo } = rebuildLabelsAndPositions(
        new vis.DataSet(baseFilteredNodes.get()), 
        baseFilteredEdges,
        currentFocusedInstanceId,
        circularFilteredViewCheckbox.checked
    );
    
    updateNetworkView(nodesWithUpdatedInfo, edgesWithUpdatedInfo, `Filtered for ${selectedInstanceName}.`);
    secondaryFiltersContainer.style.display = 'flex';
    populateConnectedNodeFilter(connectedNodesForDropdown); resetSecondaryFilterInputs(); 
  });

  function resetSecondaryFilterInputs() {
    protocolFilterInput.value = ""; portFilterInput.value = "";
    Array.from(connectedNodeFilterSelect.options).forEach(opt => opt.selected = false); 
  }

  function populateConnectedNodeFilter(nodesMap) {
    connectedNodeFilterSelect.innerHTML = ''; 
    const sorted = Array.from(nodesMap.entries()).sort((a,b) => a[1].localeCompare(b[1]));
    sorted.forEach(([id, name]) => {
        const opt = document.createElement('option');
        opt.value = id; opt.textContent = name;
        connectedNodeFilterSelect.appendChild(opt);
    });
  }

  applySecondaryFiltersBtn.addEventListener('click', applyAdvancedFilters);
  resetSecondaryFiltersBtn.addEventListener('click', () => {
    resetSecondaryFilterInputs();
    const event = new Event('change'); 
    instanceFilterSelect.dispatchEvent(event);
  });

  circularFilteredViewCheckbox.addEventListener('change', () => {
    if (currentFocusedInstanceId) { 
        const event = new Event('change'); 
        instanceFilterSelect.dispatchEvent(event);
    }
  });


  function applyAdvancedFilters() {
    if (!currentFocusedInstanceId || baseFilteredNodes.length === 0) { status.textContent = "No primary selection."; return; }

    const protocolQuery = protocolFilterInput.value.trim().toLowerCase();
    const portQuery = portFilterInput.value.trim();
    const selectedConnectedNodeOptions = Array.from(connectedNodeFilterSelect.selectedOptions);
    const selectedConnectedNodeIds = selectedConnectedNodeOptions.map(opt => opt.value).filter(val => val !== "");

    let subFilteredEdges = new vis.DataSet();
    let subFilteredNodeIds = new Set([currentFocusedInstanceId]); 

    baseFilteredEdges.forEach(edge => {
        let matches = true;
        if (selectedConnectedNodeIds.length > 0) { 
            if (!((edge.from === currentFocusedInstanceId && selectedConnectedNodeIds.includes(edge.to)) || 
                  (edge.to === currentFocusedInstanceId && selectedConnectedNodeIds.includes(edge.from)))) {
                matches = false;
            }
        }
        const [edgeProtocol, edgePortRange] = edge.protocolPortData.split(':');
        if (matches && protocolQuery) {
            if (edgeProtocol !== 'all' && protocolQuery !== 'all' && !edgeProtocol.includes(protocolQuery)) {
                matches = false;
            }
        }
        if (matches && portQuery) {
            if (edgePortRange !== 'any' && !checkPortMatch(edgePortRange, portQuery)) {
                matches = false;
            }
        }
        if (matches) {
            subFilteredEdges.add({...edge, id: edge.id + "_sub"}); 
            subFilteredNodeIds.add(edge.from); subFilteredNodeIds.add(edge.to);
        }
    });

    const subFilteredNodesData = baseFilteredNodes.get({ filter: node => subFilteredNodeIds.has(node.id) });
    let finalSubFilteredNodes = new vis.DataSet(subFilteredNodesData);
    
    const { nodesWithUpdatedInfo, edgesWithUpdatedInfo } = rebuildLabelsAndPositions(
        finalSubFilteredNodes, 
        subFilteredEdges,
        currentFocusedInstanceId,
        circularFilteredViewCheckbox.checked
    );
    
    const selectedInstanceName = instanceMap[currentFocusedInstanceId]?.name || currentFocusedInstanceId;
    updateNetworkView(nodesWithUpdatedInfo, edgesWithUpdatedInfo, `Sub-filter applied for ${selectedInstanceName}.`);
  }

  function checkPortMatch(edgePortRange, queryPort) {
    if (edgePortRange === queryPort) return true;
    if (edgePortRange.includes('-')) {
        const [start, end] = edgePortRange.split('-').map(Number);
        const qPort = Number(queryPort);
        if (!isNaN(qPort) && qPort >= start && qPort <= end) return true;
    }
    return false;
  }
  
function rebuildLabelsAndPositions(currentDisplayNodes, currentDisplayEdges, focusedId, isCircularLayout) {
    const nodeInteractionDetails = new Map(); 
    const nodesWithUpdatedInfo = new vis.DataSet();

    currentDisplayNodes.forEach(node => {
        const originalGlobalNode = globalNodes.get(node.id);
        let baseLabel = node.label; 
        let initialTitle = node.title; 

        if (originalGlobalNode) {
            baseLabel = originalGlobalNode.label; 
            if ((isCircularLayout || !focusedId) ) { 
                 baseLabel = originalGlobalNode.label.split('\n')[0];
            }
            initialTitle = originalGlobalNode.title; 
        }
        
        nodeInteractionDetails.set(node.id, { 
            connectionLines: new Set(), 
            baseLabel: baseLabel,
            initialTitle: initialTitle, 
            originalNodeData: {...node} 
        });
    });

    currentDisplayEdges.forEach(edge => {
        const [protocol, port] = edge.protocolPortData.split(':');
        const fromNodeId = edge.from;
        const toNodeId = edge.to;
        
        const fromNodeGlobal = globalNodes.get(fromNodeId);
        const toNodeGlobal = globalNodes.get(toNodeId);

        const fromNodeName = instanceMap[fromNodeId]?.originalName || fromNodeGlobal?.label.split('\n')[0] || fromNodeId;
        const toNodeName = instanceMap[toNodeId]?.originalName || toNodeGlobal?.label.split('\n')[0] || toNodeId;
        const viaSg = edge.sgNameData || "Unknown SG";

        const addDetail = (nodeIdToAddDetail, detailLine) => {
            if (nodeInteractionDetails.has(nodeIdToAddDetail)) {
                nodeInteractionDetails.get(nodeIdToAddDetail).connectionLines.add(detailLine);
            }
        };

        if (fromNodeId === focusedId) { // Outbound from focused
            addDetail(focusedId, `Out to ${toNodeName}: ${protocol}:${port} (via ${viaSg})`);
            addDetail(toNodeId, `In from ${fromNodeName}: ${protocol}:${port} (via ${viaSg})`);
        } else if (toNodeId === focusedId) { // Inbound to focused
            addDetail(focusedId, `In from ${fromNodeName}: ${protocol}:${port} (via ${viaSg})`);
            addDetail(fromNodeId, `Out to ${toNodeName}: ${protocol}:${port} (via ${viaSg})`);
        }
    });
    
    currentDisplayNodes.forEach(node => {
        const details = nodeInteractionDetails.get(node.id);
        let finalLabel = details.baseLabel;
        let finalTitle = details.initialTitle; 

        if (details.connectionLines.size > 0) {
            const connectionSummary = Array.from(details.connectionLines).sort().join('\n');
            finalTitle += '\n\nConnections (to/from focused):\n' + connectionSummary;
            if (!isCircularLayout && focusedId) { 
                finalLabel += '\n' + connectionSummary;
            }
        }
        
        nodesWithUpdatedInfo.add({
            ...details.originalNodeData, 
            label: finalLabel, 
            title: finalTitle,
            font: {size:10, multi:true, align:'left', vadjust: -5} 
        });
    });

    if (isCircularLayout && nodesWithUpdatedInfo.length > 0) {
        const networkContainer = document.getElementById('network');
        arrangeNodesInCircle(nodesWithUpdatedInfo, networkContainer.clientWidth, networkContainer.clientHeight);
    } else if (nodesWithUpdatedInfo.length > 0 && focusedId) { 
        const focusedNodeUpdate = nodesWithUpdatedInfo.get(focusedId);
        if(focusedNodeUpdate) nodesWithUpdatedInfo.updateOnly({id: focusedId, x: -500, y: 0, fixed: {x:true, y:true}});
        
        const connectedNodesForPos = nodesWithUpdatedInfo.get({ filter: n => n.id !== focusedId });
        const vSpacing = Math.max(80, 15 * (nodeInteractionDetails.get(focusedId)?.connectionLines.size || 1) + 60);
        const initY = -((connectedNodesForPos.length - 1) * vSpacing) / 2;
        connectedNodesForPos.forEach((node, index) => {
            nodesWithUpdatedInfo.updateOnly({id: node.id, x: 500, y: initY + index * vSpacing, fixed: {x:true, y:true}});
        });
    }

    return { nodesWithUpdatedInfo: nodesWithUpdatedInfo, edgesWithUpdatedInfo: currentDisplayEdges };
}


  function updateNetworkView(nodesToDisplay, edgesToDisplay, statusMessage) {
    let finalEdges = new vis.DataSet(edgesToDisplay.get()); 
    let defaultEdgeSmooth = circularFilteredViewCheckbox.checked && currentFocusedInstanceId ? 
                           { type: "cubicBezier", forceDirection: 'none', roundness: 0.2 } : 
                           { type: 'straightCross', roundness: 0 };

    finalEdges.forEach(edge => { 
        finalEdges.updateOnly({id: edge.id, smooth: defaultEdgeSmooth});
    });

    if (nodesToDisplay.length === 2 && currentFocusedInstanceId && !circularFilteredViewCheckbox.checked) { 
        const nodeIds = nodesToDisplay.getIds();
        if (nodeIds.length === 2) { 
            const nodeA = nodeIds[0]; const nodeB = nodeIds[1];
            const edgesBetweenPair = finalEdges.get({
                filter: edge => ((edge.from === nodeA && edge.to === nodeB) || (edge.from === nodeB && edge.to === nodeA))
            });

            if (edgesBetweenPair.length === 2) { 
                let firstEdgeDirection = null;
                edgesBetweenPair.forEach((edge, index) => {
                    let updatedSmooth;
                    if (index === 0) { 
                        updatedSmooth = { type: 'curvedCW', roundness: 0.2, forceDirection: 'none' };
                        firstEdgeDirection = (edge.from === currentFocusedInstanceId) ? 'outbound' : 'inbound';
                    } else { 
                        if (firstEdgeDirection === 'outbound' && edge.to === currentFocusedInstanceId) { 
                            updatedSmooth = { type: 'curvedCCW', roundness: 0.2, forceDirection: 'none' };
                        } else if (firstEdgeDirection === 'inbound' && edge.from === currentFocusedInstanceId) { 
                            updatedSmooth = { type: 'curvedCCW', roundness: 0.2, forceDirection: 'none' };
                        } else { 
                            updatedSmooth = { type: 'curvedCCW', roundness: 0.2, forceDirection: 'none' };
                        }
                    }
                    finalEdges.updateOnly({id: edge.id, smooth: updatedSmooth});
                });
            } else if (edgesBetweenPair.length === 1) { 
                 finalEdges.updateOnly({id: edgesBetweenPair[0].id, smooth: { type: 'straightCross', roundness: 0 }});
            }
        }
    }
    
    const viewOptions = {
      physics: false, interaction: { dragNodes: false, dragView: true, zoomView: true, hover: true, tooltipDelay: 200 },
      edges: { width: 1.5, font: { size: 8, align: 'middle' }, arrows: { to: { enabled: true, scaleFactor: 0.8 } }  },
      nodes: { borderWidth: 1, borderWidthSelected: 2 }
    };
    network.setOptions(viewOptions); 
    network.setData({ nodes: nodesToDisplay, edges: finalEdges });
    network.fit({ animation: { duration: 300, easingFunction: "easeInOutQuad" } }); 
    status.textContent = statusMessage;
  }

  // Modal close functionality
  modalCloseBtn.onclick = function() { nodeDetailModal.style.display = "none"; }
  helpModalCloseBtn.onclick = function() { helpModal.style.display = "none"; }
  instancesHelpIcon.onclick = function() { helpModal.style.display = "block"; }
  sgsHelpIcon.onclick = function() { helpModal.style.display = "block"; }

  window.onclick = function(event) { 
    if (event.target == nodeDetailModal) nodeDetailModal.style.display = "none";
    if (event.target == helpModal) helpModal.style.display = "none";
  }

  // Event listeners
  instanceFileInput.addEventListener('change', e => loadJsonFromFile(e.target, data => { instancesJson = data; checkFilesReady(); }));
  sgFileInput.addEventListener('change', e => loadJsonFromFile(e.target, data => { sgsJson = data; checkFilesReady(); }));
  generateBtn.addEventListener("click", generateDiagram);
  stateFilterSelect.addEventListener('change', generateDiagram); 

</script>
</body>
</html>
